/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      ByFrameApi.cpp                             ||
||     Author:    Autogenerated                              ||
||     Generated: 01.11.2021                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/

#include "ByFrameApi.hpp"
//#include <.stringPool.h>

Wave::Test::ByFrameApi::ByFrameApi(void) : PerFrameType()
{
    
}

Wave::Test::ByFrameApi::~ByFrameApi(void)
{
  //  cases.Clear(true);
 //   PerTypeTests::~PerTypeTests();
}


#define F32_MONO_FRAME f32,2

int Wave::Test::ByFrameApi::runTestCase(const AudioFrameType* frametype)
{
    PrintLog("************ convert frame **************\n");     
    IAudioFrame* frame = frametype->CreateFrame(testdata);
    const double chanval = frame->SampleTypeMaxValue()/frame->Channels();
    for ( int i = 0; i < frame->Channels(); ++i ) {
        FRAMETYPE_SWITCH( frametype->Code(),
            CASE_TYPE::TY smpl = CASE_TYPE::TY(i*chanval);
            frame->SetChannel( (frame->Channels()-1)-i, &smpl );
        )
    }
    PrintLog("channel samples: \n");
    PrintLog( FrameToString(frame) );

    int fail = 0;
    FRAMETYPE_SWITCH( frametype->Code(),
        CASE_TYPE::FRAME flfr = *(CASE_TYPE::FRAME*)frame->Channel[0];
        Wave::Frame<F32_MONO_FRAME> conv = flfr.converted<F32_MONO_FRAME>();
        PrintLog( pool_setFl( "---->>>> to float32 stereo:  %f", flfr.channel[0] ) );
        PrintLog( pool_setFl(", %f\n", flfr.channel[1]));
        fail = flfr.channel[0] == 0.0f ? 1 : 0;
    )

    delete frame;
    return fail;
}
